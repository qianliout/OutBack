# 6. 查询处理

## 6.1 实现原理

查询处理（Query Processing）是RAG系统中检索阶段的起点，它负责对用户的原始输入进行一系列的优化和转换，以生成一个对后续检索步骤（无论是稀疏检索还是稠密检索）更“友好”、更有效的查询。其核心目标是弥合用户自然语言表达与知识库文档之间的“词汇鸿沟”（Vocabulary Gap）和意图鸿沟。

查询处理的主要技术包括：

1.  **用户问题向量化（Query Vectorization）**：
    *   **原理**：这是最基础也是最核心的一步。它使用与文档索引阶段 **完全相同** 的Embedding模型，将用户的查询文本转换为一个高维向量。这个查询向量（Query Vector）是后续所有稠密检索和语义相似度计算的基石。
    *   **公式**：$\vec{q} = \text{EmbeddingModel}(\text{user_query})$

2.  **查询转换/重写（Query Transformation/Rewriting）**：
    *   **原理**：在将查询向量化之前或之后，对其进行改写，使其包含更丰富、更明确的检索信号。这是一个提升检索效果的关键优化点。
    *   **常见方法**：
        *   **查询扩展（Query Expansion）**：这是最常用的技术。它通过为原始查询补充额外的关键词或短语来扩大检索范围，从而提高召回率。扩展的词汇可以来自：
            *   **同义词词典**：如将“AI”扩展为“人工智能”、“机器智能”。您的 `query_expander.py` 就是采用的这种方式。
            *   **上位词/下位词**：如将“笔记本”扩展为“电子产品”。
            *   **LLM生成**：让一个LLM根据原始查询生成多个不同措辞的、但意图相同的新查询，然后将这些查询的向量进行平均，或者并行执行检索。
        *   **查询分解（Query Decomposition）**：当用户提出一个复杂问题时（如“RAG和微调有什么区别，哪个更适合知识更新频繁的场景？”），可以将其分解为多个更简单的子问题（“RAG和微调的区别是什么？”、“哪种技术适合知识更新？”），然后分别对子问题进行检索，最后汇总结果。
        *   **指代消解（Coreference Resolution）**：在多轮对话中，用户可能会使用“它”、“那个”等代词。需要将这些代词解析并替换为它们所指向的实际实体，以形成一个完整的、无歧义的查询。

3.  **检索流程优化（Retrieval Flow Optimization）**：
    *   **原理**：设计更智能的检索流程，而不是简单的“一查到底”。
    *   **方法**：
        *   **HyDE (Hypothetical Document Embeddings)**：一种有趣的技术。它不直接向量化用户的查询，而是先让LLM根据查询“想象”并生成一个假设性的、理想的答案文档。然后，它向量化这个假设的文档，并用这个文档的向量去知识库中进行搜索。其背后的思想是，一个（即使是虚构的）答案文档在向量空间中可能比原始的、简短的问题更接近真实的答案文档。

## 6.2 所解决的问题

1.  **词汇不匹配（Vocabulary Mismatch）**：用户提问的方式是多样的，他们使用的词语可能与知识库文档中的词语不完全一致。查询扩展通过增加同义词、相关词，极大地缓解了这个问题，确保即使措辞不同也能找到相关内容。
2.  **查询意图模糊**：用户的查询通常很简短，可能包含的检索信号不足。查询扩展和重写可以丰富查询的上下文，使其意图更明确，从而引导检索器找到更精准的结果。
3.  **提高召回率（Recall）**：这是查询处理最直接的目标。通过扩展查询，增加了命中相关文档的可能性。一个查询从 `“RAG”` 扩展到 `“RAG 检索 增强 生成”`，就更有可能召回那些只包含部分关键词但内容相关的文档。
4.  **优化多轮对话体验**：在连续的对话中，通过指代消解等技术，系统能够理解上下文，使得对话更加自然流畅，避免了让用户重复输入已经提过的信息。

## 6.3 核心代码

在您的 `./rag` 项目中，查询处理主要由 `query_expander.py` 和 `retriever.py` 协同完成。

### 6.3.1 简单查询扩展器 (`SimpleQueryExpander`)

这个类使用一个手动的同义词词典来实现查询扩展，是该原理的一个很好的教学示例。

```python
# rag/query_expander.py

class SimpleQueryExpander:
    def __init__(self, ...):
        # ...
        # 手动构建的同义词词典
        self.synonym_dict = self._build_synonym_dict()

    def expand_query(self, query: str, ...) -> QueryExpansionResult:
        # ...
        # 1. 对原始查询分词
        words = self.tokenizer.tokenize(query, ...).tokens
        
        # 2. 在词典中查找同义词
        synonym_pairs = {}
        for word in words:
            if word in self.synonym_dict:
                synonyms = self.synonym_dict[word][...]
                synonym_pairs[word] = synonyms
        
        # 3. 构建最终的扩展后查询字符串
        expanded_query = self._build_expanded_query(query, synonym_pairs, ...)
        
        return QueryExpansionResult(..., expanded_query=expanded_query, ...)
```

### 6.3.2 在检索器中应用查询扩展 (`HybridRetrieverManager`)

`HybridRetrieverManager` 在执行检索前，会先调用 `SimpleQueryExpander`。

```python
# rag/retriever.py

class HybridRetrieverManager:
    def __init__(self, ...):
        # ...
        # 初始化查询扩展器
        self.query_expander = SimpleQueryExpander(enable_expansion=True)

    def _hybrid_retrieve(self, query: str, ...):
        # ...
        # 1. 查询扩展是检索流程的第一步
        expanded_query = query
        if use_query_expansion:
            expansion_result = self.query_expander.expand_query(query)
            expanded_query = expansion_result.expanded_query
            self.logger.debug(f"查询扩展: '{query}' -> '{expanded_query}'")

        # 2. 使用扩展后的查询进行ES粗排
        es_results = self.es_manager.search_documents(expanded_query, ...)
        # ...
```

## 6.4 实际工程中的应用

*   **基于LLM的查询重写**：这是目前最前沿和效果最好的方法。不再依赖手动的同义词词典，而是直接利用LLM的强大语言理解和生成能力。例如，可以设计一个Prompt，要求LLM：“请将以下用户查询改写成一个更适合数据库检索的关键词查询”，或者“请为以下问题生成3个不同角度的相似问题”。
*   **查询分类（Query Classification）**：在处理查询之前，先对其进行分类。例如，判断查询是“关键词查询”、“事实问答查询”还是“闲聊查询”。根据不同的分类，可以采用完全不同的处理策略。对于关键词查询，可以增强BM25的权重；对于事实问答，则可以更依赖向量检索。
*   **结构化查询生成**：对于能够连接数据库的RAG系统（Text-to-SQL），查询处理模块会负责将用户的自然语言问题（如“上个季度销售额最高的三个产品是什么？”）直接转换成可执行的SQL查询语句。
*   **A/B测试**：工程上会通过A/B测试来不断迭代和优化查询处理的策略。例如，比较不同查询扩展方法带来的点击率、答案满意度等指标的变化，来决定哪种策略最终上线。

## 6.5 面试题及答案

**1. 什么是“查询扩展”（Query Expansion）？它试图解决什么问题？**

*   **答案**：
    *   **查询扩展** 是一种在信息检索中优化用户查询的技术。它的核心思想是向用户的原始查询中添加额外的、相关的词语（如同义词、近义词、相关词等），以创建一个内容更丰富、更可能命中相关文档的新查询。
    *   它主要试图解决 **“词汇不匹配”** 的问题。用户用来描述一个概念的词语，和文档中使用的词语可能完全不同。例如，用户搜索“AI教程”，但最好的文档标题可能是“人工智能入门指南”。通过将查询扩展为“AI 人工智能 教程 指南”，就能同时召回这两类文档，从而显著 **提高检索的召回率（Recall）**。

**2. 除了使用同义词词典，你还知道哪些实现查询扩展的方法？**

*   **答案**：有多种更先进的方法：
    1.  **基于LLM生成**：这是目前非常流行且有效的方法。可以利用大型语言模型（如GPT）的生成能力，根据原始查询生成多个语义相同但措辞不同的新查询。例如，Prompt可以是：“请为问题‘RAG如何工作？’生成3个等价的问题。”
    2.  **伪相关反馈（Pseudo-Relevance Feedback）**：这是一个经典的IR技术。它首先用原始查询进行一次初步检索，并假设返回的Top-K个文档是相关的。然后，它会分析这些“伪相关”文档中的高频词或重要词，并将这些词添加到原始查询中，形成一个新查询，再进行第二次、更精确的检索。
    3.  **基于词向量的方法**：可以在词向量空间中，找到与查询中关键词向量最接近的其他词向量，并将这些词作为扩展词。

**3. 在一个多轮对话的RAG系统中，如果用户第二轮问“它有什么优点？”，查询处理模块应该做什么？**

*   **答案**：这是一个典型的需要 **上下文理解** 和 **指代消解（Coreference Resolution）** 的场景。查询处理模块不能直接处理“它有什么优点？”这个模糊的查询。它需要做以下几步：
    1.  **访问对话历史**：获取上一轮的对话内容。假设上一轮用户问的是“什么是RAG系统？”。
    2.  **执行指代消解**：识别出查询中的代词“它”指向的是上一轮对话的核心主题“RAG系统”。
    3.  **重写查询**：将原始查询重写为一个独立的、完整的查询，即“RAG系统有什么优点？”。
    4.  **执行后续流程**：将这个重写后的、无歧义的查询传递给向量化和检索模块。
    *   这个过程确保了即使在连续的对话中，系统也能正确理解用户的意图。

**4. 什么是HyDE (Hypothetical Document Embeddings)？它的工作原理是怎样的？**

*   **答案**：
    *   **HyDE** 是一种新颖的查询转换技术，全称是“假设性文档嵌入”。
    *   **工作原理**：传统的做法是直接将用户的查询（Query）向量化，然后用这个查询向量去搜索文档。HyDE另辟蹊径，它认为用户的简短查询在向量空间中可能与长而详细的答案文档“分布不匹配”。因此，它的步骤是：
        1.  **生成假设性文档**：接收到用户查询后，它不直接向量化查询，而是先将其输入给一个LLM，并要求LLM根据这个查询生成一个“假设性的”答案文档。这个文档不需要完全正确，只需要在内容和风格上像一个真实的答案即可。
        2.  **向量化假设性文档**：然后，HyDE会用Embedding模型来向量化这个生成的、假设性的文档。
        3.  **进行检索**：最后，它使用这个“假设性文档的向量”去知识库中进行相似性搜索，以找到真实的、相关的文档。
    *   其核心思想是，一个（即使是虚构的）答案在向量空间中，比一个简短的问题，离一个真实的答案更“近”。这种方法在很多场景下被证明可以提高检索的精度。
